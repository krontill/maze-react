{"version":3,"sources":["maze/index.js","App.js","serviceWorker.js","index.js"],"names":["Maze","state","width","height","maze","_this$state","this","i","j","generation","randomRemoveWall","setState","neighbourCell","currentCell","x","y","mazeCellVisited","push","neighbours","getNeighbours","length","Math","floor","random","removeWall","indexcurrentCell","indexOf","split","unvisitedCount","_this$state2","count","addX","addY","xDiff","yDiff","target","abs","current","distance","_this$state3","up","rt","dw","lt","d","cellCurrentNeighbours","_this$state4","_this$state5","cells","react_default","a","createElement","key","className","wallGenerator","generateCells","Component","defaultProps","App","src_maze","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.6d3b6ac5.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\nimport './style.css';\r\n\r\n// За основу взята статья https://habr.com/post/262345/\r\n\r\nclass Maze extends Component {\r\n\tstatic defaultProps = {};\r\n\r\n\tstatic propTypes = {};\r\n\r\n\tstate = {\r\n\t\twidth: 45,\r\n\t\theight: 45,\r\n\t\tmaze: []\r\n\t};\r\n\r\n\twallGenerator() {\r\n\t\tconst {width, height} = this.state;\r\n\t\tlet maze = [];\r\n\t\tfor (let i = 0; i < height; i++) {\r\n\t\t\tmaze[i] = [];\r\n\t\t\tfor (let j = 0; j < width; j++) {\r\n\t\t\t\tif ((i % 2 !== 0 && j % 2 !== 0) && (i < height - 1 && j < width - 1)) {\r\n\t\t\t\t\tmaze[i][j] = 0; //Cell;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmaze[i][j] = 1; //Wall;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.generation(maze);\r\n\t\tthis.randomRemoveWall(maze);\r\n\t\tthis.setState({maze});\r\n\t}\r\n\r\n\tgeneration(maze) {\r\n\t\tlet currentCell = {x: 1, y: 1};\r\n\t\tlet mazeCellVisited = [];\r\n\t\tmazeCellVisited.push(currentCell.x + '-' + currentCell.y);\r\n\t\tlet neighbourCell;\r\n\t\tdo {\r\n\t\t\tlet neighbours = this.getNeighbours(maze, mazeCellVisited, currentCell, 2);\r\n\t\t\tif (neighbours.length !== 0) { //если у клетки есть непосещенные соседи\r\n\t\t\t\tneighbourCell = neighbours[Math.floor(Math.random() * neighbours.length)]; //выбираем случайного соседа\r\n\t\t\t\tmaze = this.removeWall(currentCell, neighbourCell, maze); //убираем стену между текущей и соседней точками\r\n\t\t\t\tcurrentCell = neighbourCell; //делаем соседнюю точку текущей и отмечаем ее посещенной\r\n\t\t\t\tmazeCellVisited.push(currentCell.x + '-' + currentCell.y); //заносим текущую точку в стек\r\n\t\t\t}\r\n\t\t\telse if (neighbours.length === 0) { //если нет соседей, возвращаемся на предыдущую точку\r\n\t\t\t\tlet indexcurrentCell = mazeCellVisited.indexOf(currentCell.x + '-' + currentCell.y);\r\n\t\t\t\tif (~indexcurrentCell) { // Если у последнего currentCell нет соседей, то он еще не успеет попасть в mazeCellVisited.\r\n\t\t\t\t\tcurrentCell = {x: +mazeCellVisited[indexcurrentCell - 1].split('-')[0], y: +mazeCellVisited[indexcurrentCell - 1].split('-')[1]};\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentCell = {x: +mazeCellVisited[mazeCellVisited.length - 1].split('-')[0], y: +mazeCellVisited[mazeCellVisited.length - 1].split('-')[1]};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse { //если нет соседей и точек в стеке, но не все точки посещены, выбираем случайную из непосещенных\r\n\t\t\t\t/*cellString\r\n\t\t\t\tcellStringUnvisited = getUnvisitedCells(width, height, maze);\r\n\t\t\t\trandNum = randomRange(0, cellStringUnvisited.size - 1);\r\n\t\t\t\tcurrentCell = cellStringUnvisited.cells[randNum];\r\n\t\t\t\tfree(cellStringUnvisited.cells);*/\r\n\t\t\t}\r\n\t\t} while (this.unvisitedCount(maze, mazeCellVisited) > 0);\r\n\t}\r\n\r\n\tunvisitedCount(maze, mazeCellVisited) {\r\n\t\tlet {width, height} = this.state;\r\n\t\tlet count = 0;\r\n\t\tfor (let i = 0; i < height; i++) {\r\n\t\t\tfor (let j = 0; j < width; j++) {\r\n\t\t\t\tif (i % 2 && j % 2 && maze[i][j] !== 1 && !~mazeCellVisited.indexOf(i + '-' + j)) { //i % 2 && j % 2 изначально непосещенные\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\tremoveWall(currentCell, neighbourCell, maze) {\r\n\t\tlet xDiff = neighbourCell.x - currentCell.x;\r\n\t\tlet yDiff = neighbourCell.y - currentCell.y;\r\n\t\tlet addX, addY;\r\n\t\tlet target = {};\r\n\r\n\t\taddX = (xDiff !== 0) ? (xDiff / Math.abs(xDiff)) : 0;\r\n\t\taddY = (yDiff !== 0) ? (yDiff / Math.abs(yDiff)) : 0;\r\n\r\n\t\ttarget.x = currentCell.x + addX; //координаты стенки\r\n\t\ttarget.y = currentCell.y + addY;\r\n\r\n\t\tmaze[target.y][target.x] = 0;//VISITED;\r\n\t\treturn maze;\r\n\t}\r\n\r\n\tgetNeighbours(maze, mazeCellVisited, current, distance) {\r\n\t\tlet {width, height} = this.state;\r\n\t\tlet x = current.x;\r\n\t\tlet y = current.y;\r\n\t\tlet up = {x, y: current.y - distance};\r\n\t\tlet rt = {x: x + distance, y};\r\n\t\tlet dw = {x, y: y + distance};\r\n\t\tlet lt = {x: x - distance, y};\r\n\t\tlet d = [];\r\n\t\td.push(dw, rt, up, lt);\r\n\t\tlet cellCurrentNeighbours = [];\r\n\r\n\t\tfor (let i = 0; i < 4; i++) { //для каждого направдения\r\n\t\t\tif (d[i].x > 0 && d[i].x < width && d[i].y > 0 && d[i].y < height) { //если не выходит за границы лабиринта\r\n\t\t\t\tif (maze[d[i].y][d[i].x] !== 1 && !~mazeCellVisited.indexOf(d[i].x + '-' + d[i].y)) { //и не посещена\\является стеной  && mazeCellCurrent !== VISITED\r\n\t\t\t\t\tcellCurrentNeighbours.push(d[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn cellCurrentNeighbours;\r\n\t}\r\n\r\n\trandomRemoveWall(maze) {\r\n\t\tconst {width, height} = this.state;\r\n\t\tfor (let i = 1; i < height - 1; i++) {\r\n\t\t\tfor (let j = 1; j < width - 1; j++) {\r\n\t\t\t\tif (maze[i][j] === 1) {\r\n\t\t\t\t\tif (!(Math.random() * 100 ^ 0) % 17) {\r\n\t\t\t\t\t\tmaze[i][j] = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn maze;\r\n\t}\r\n\r\n\tgenerateCells() {\r\n\t\tconst {width, height, maze} = this.state;\r\n\t\tlet cells = [];\r\n\t\tif (maze.length) {\r\n\t\t\tfor (let i = 0; i < height; i++) {\r\n\t\t\t\tcells[i] = [];\r\n\t\t\t\tfor (let j = 0; j < width; j++) {\r\n\t\t\t\t\tcells[i].push(<div key={i + j} className={maze[i][j] === 0 ? 'cell' : 'wall'}>&nbsp;</div>);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cells;\r\n\t}\r\n\r\n\tcomponentDidMount() {\r\n\t\tthis.wallGenerator();\r\n\t}\r\n\r\n\trender() {\r\n\t\tlet cells = this.generateCells();\r\n\t\treturn (\r\n\t\t\t<div className='maze'>\r\n\t\t\t\t{cells}\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nexport default Maze;","import React, {Component} from 'react';\r\nimport './App.css';\r\nimport Maze from './maze/index';\r\n\r\nclass App extends Component {\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<div className=\"app\">\r\n\t\t\t\t<Maze/>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}